# Node.js - Koa2 框架 （微博）

## 第一章：整体知识点

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210904194638983.png" alt="image-20210904194638983" style="zoom: 25%;" />



## 第二章 技术选型

### 1、框架模型

```markdown
# express vs koa2 vs egg

```



### 2、创建项目

```markdown
# 步骤
		1、安装koa-generator  [第一次安装就行了  ]
    		进入一个文件夹 （eg /Users/doghuang/Desktop/工作/koa2-weibo）
				npm install -g koa-generator
		2、检查node的版本 > 8.0
		
		3、创建项目
			koa2 -e 项目名称
				eg:  koa2 -e koa2-weibo-code
				
		4、进入目录 cd koa2-weibo-code 
		
		5、安装 依赖 npm i
```



### 3、启动

```markdown
npm run dev

http://localhost:3000/
```



### 4、上传项目到github

```markdown
1、创建git 仓库， git init
```

![image-20210904224851655](/Users/doghuang/Library/Application Support/typora-user-images/image-20210904224851655.png)

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210904224940655.png" alt="image-20210904224940655" style="zoom: 50%;" />

```markdown
2、在github中创建一个空的仓库
```

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210904231336245.png" alt="image-20210904231336245" style="zoom: 50%;" />

```markdown
3、找到仓库的https地址
	eg: https://github.com/lijiesheng/--koa2.git
```

![image-20210904231437639](/Users/doghuang/Library/Application Support/typora-user-images/image-20210904231437639.png)

```markdown
4、把本地的仓库关联到github.com 上面
	 git remote add origin https://github.com/sci99coder/vuetodo.git
	 
5、git add .

6、git commit -m '1'

7、git push origin master:master 
```



### 5、设置环境变量

```markdown
9、安装环境变量插件
	npm i cross-env -D
```

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210904232951951.png" alt="image-20210904232951951" style="zoom:67%;" />



### 6、代码结构

```markdown
1、创建	src 目录
2、将public文件夹 router文件夹 view文件夹 app.js 文件放入src 目录
```

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210904233448862.png" alt="image-20210904233448862" style="zoom: 67%;" />

![image-20210904233647320](/Users/doghuang/Library/Application Support/typora-user-images/image-20210904233647320.png)





### 7、代码提交commit 规范

```markdown
feat：新功能（feature）

fix：修补bug

docs：文档（documentation）

style： 格式（不影响代码运行的变动）

refactor：重构（即不是新增功能，也不是修改bug的代码变动）

test：增加测试

chore：构建过程或辅助工具的变动

build :改变了build工具 如 grunt换成了 npm

revert: 撤销上一次的 commit

	eg : git commit -m "refactor : 目录调整"
```



### 8、返回路由

> get 请求

```markdown
# 不传参数 json返回
router.get('/json', async (ctx, next) => {
  ctx.body = {
    title: 'koa2 json'
  }
})


# 传参数 json返回
router.get('/profile/:userName', async (ctx, next) => {
  let params = ctx.params;
  console.log("params====>",params);
  ctx.body = {
    title: 'this is a profile',
    userName : params.userName
  }
})

# 传多个参数 json返回
router.get('/loadMore/:userName/:pageIndex',async (ctx, next) => {
  let params = ctx.params;
  console.log("params====>",params);
  ctx.body = {
    title: 'this is a profile',
    userName : params.userName,
    pageIndex : params.pageIndex
  }
})
```

> post 请求

```markdown
router.post('/login',async (ctx, next) => {
  let params = ctx.request.body;
  console.log("params====>",params);
  ctx.body = {
    userName : params.userName,
    password : params.password
  }
})
```



### 9、ejs 介绍

```markdown
1、变量 （输出） <%= xxx %> 输出一个变量

  # 向前端传送了一个title 和 msg
  router.get('/', async (ctx, next) => {
    console.log("aaa ====");
    // 返回页面
    await ctx.render('index', {
      title: 'Hello Koa 2!',
      msg : 'this is a msg'
    })
  })
  
  # 在app.js 中注册了页面 【已经存在的】
  app.use(views(__dirname + '/views', {
    extension: 'ejs'
  }))
  
  # 前端显示
   <body>
    <h1><%= title %></h1>          显示前端的 title 
    <p>EJS Welcome to <%= title %></p>  显示前端的 title 
    <p><%= msg %></p>   显示前端的 msg
  </body>
 
2、判断
	# 判断 isMe  前端
    router.get('/', async (ctx, next) => {
    console.log("aaa ====");
    // 返回页面
    await ctx.render('index', {
      title: 'Hello Koa 2!',
      msg : 'this is a msg,您好',
      isMe : true
    })
  })
  
  # 后端 
  <body>
    <h1><%= title %></h1>
    <p>EJS Welcome to <%= title %></p>
    <p><%= msg %></p>
    <div>
        <% if (isMe) { %>
          <a href="#">@ 提到我的(3)</a>
        <% } else {
          %>
          <a href="#">@ 提到我的(2)</a>
        <% 
        }%>
    </div>
  </body>



3、循环
	1、创建组件，在widgets文件夹中创建一个blog-list文件
      <ul>
        <% blogList.forEach( blog => { %>
            <li> <%= blog.title %> </li>
        <% }) %>
     </ul>
   2、引用  在index.ejs中加入
       <hr>
          <%- include('widgets/blog-list', {
            blogList : blogList
   		 })%>
   		 
   3、在后端中加入
   	router.get('/', async (ctx, next) => {
    console.log("aaa ====");
    // 返回页面
      await ctx.render('index', {
        title: 'Hello Koa 2!',
        msg : 'this is a msg,您好',
        isMe : true,
        blogList : [
          {
            id : 1,
            title : "aaa"
          },
          {
            id : 2,
            title : "bbb"
          },
          {
            id : 3,
            title : "ccc"
          }
        ]
      })
  })


4、引用组件
	1、在view 文件夹中专门新建一个widgets 文件夹
	2、在widgets 文件夹中创建一个user-info.ejs文件，在问价中添加代码
      <div>
      <% if (isMe) { %>
        <a href="#">@ 提到我的(3)</a>
      <% } else { %>
        <a href="#">@ 提到我的(2)</a>
      <% }%>
     </div>
  
  3、调用组件
  	 <body>
      <h1><%= title %></h1>
      <p>EJS Welcome to <%= title %></p>
      <p><%= msg %></p>

      <%- include('widgets/user-info',{
        isMe : isMe
      })%>
  	</body>
```



> 遇到的问题

```markdown
ssh: Could not resolve hostname github.com: nodename nor servname provided, or not known

第一步：查找github.com 的ip
	ping github.com
	PING github.com (20.205.243.166): 56 data bytes  得到github.com的地址
	
第二步：将github.com 的ip地址添加到hosts文件中
	sudo vi /etc/hosts
		密码是 ljs123
	在尾部插入一行  20.205.243.166 github.com
```



### 10、sequelize

```markdown
1、 ORM 

2、 建模 （外键）& 同步到数据库

3、 增删改查 & 连表查询

4、 数据表 ，用 js 中的模型（class 或对象）代替

5、 一条或多条记录，用 js 中一个对象或者数组代替

6、 sql 语句， 用对象方法代替

```

> 1、新建一个 sequelize-test 文件夹

>  2、初始化 npm init -y

> 3、安装mysql2 和 sequelize
>
> ​	npm i mysql2 sequelize -d

> 4 、在sequelize-test 创建一个文件夹 src
>
> 5、 在src 文件夹下创建 seq.js 文件

```javascript
const { Sequelize } = require('sequelize');
const sequelize = require('sequelize');

const conf = {
    host : 'localhost',
    dialect : 'mysql'
}

/**
 * 数据库名 ：koa2_weibi_test
 * 用户名 : root
 * 密码 : ljs024816
 * ip : localhost
 * 数据库类型 : mysql
 */
const seq = new Sequelize('koa2_weibi_test','root','ljs024816',conf);   // 数据库名字



// 测试连接
seq.authenticate().then( () => {
    console.log('ok');
}).catch( () => {
    console.log('err');
})

// module.exports = seq;
```

> 执行 node src/seq.js 测试数据库连接是否成功



> 6、建模 在src 目录下新建 model.js 文件

```markdown
# 在 model.js 文件中创建一个User 模型

const { Sequelize } = require('sequelize');
const seq = require('./seq');

// 创建一个模型 ，表名是users 
const User = seq.define('users',{
    // id 会自动创建，并设置为主键，自增
    userName : {
        type : Sequelize.STRING,  // varchar (255)
        allowNull : false,
        comment : '用户名'
    },
    password : {
        type : Sequelize.TEXT,  // varchar (255)
        allowNull : false,
        comment : '密码'
    },
    nickName : { // 可以为空
        type : Sequelize.STRING,  // varchar (255)
        comment : '昵称'
    }
}) 

module.exports = {
    User
}
```

> 在 src 文件创建一个sync.js

```markdown
const seq = require('./seq');
const {User} = require('./model');

// 测试连接
seq.authenticate().then( () => {
    console.log('ok');
}).catch( () => {
    console.log('err');
})


// 执行同步  force 无论有在数据库有没有表，都会删除数据库的表，然后重新创建
// process.exit() 创建完表 后退出
seq.sync({ force : true}).then( () => {
    console.log('同步成功');
    process.exit();
})
```

> 执行 node src/sync.js 可以看到在数据库创建了表

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210905205445899.png" alt="image-20210905205445899" style="zoom:50%;" />



> 创建  Blog 模型

```markdown
// 创建 Blog 模型
const Blog = seq.define('blogs', {
    // id 会自动创建，并设置为主键，自增

    title : {
        type : Sequelize.STRING,
        allowNull : false,
        comment : '标题'
    },
    content : {
        type : Sequelize.STRING,
        allowNull : false,
        comment : '内容'
    },
    userId : {
        type : Sequelize.INTEGER,
        allowNull : false
    }
})
```

> 执行node src/sync.js 可以看见数据库中的Blog 表被创建了



#### 10.1 创建外键

> 创建外键

```markdown
// 关联外键
Blog.belongsTo(User,{
    // 创建外键 Blog.userId -> User.id
    foreignKey : 'userId'
})
```

> 执行node src/sync.js
>
> 执行 show create table blogs; 查看所有字段信息

```markdown
CREATE TABLE `blogs` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL COMMENT '标题',
  `content` varchar(255) NOT NULL COMMENT '内容',
  `userId` int NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `userId` (`userId`),
  CONSTRAINT `blogs_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci


可以看到blogs 表中的userId 确实是 外键
```

> 或者执行 blogs ---> Diagrams ---> show 

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20210905213529468.png" alt="image-20210905213529468" style="zoom: 33%;" />

> 增删改查
>
> 1、创建一个create.js 文件

```markdown
const {Blog, User} = require('./model');

!(async function () {
    // 创建用户
    const zhangsan = await User.create({
        userName: 'zhangsan',
        password: '123',
        nickName: '张三'
    })

    console.log('zhangsan', zhangsan.dataValues);

    const id = zhangsan.id;


    const lisi = await User.create({
        userName: 'lisi',
        password: '123',
        nickName: '李四'
    })
    
    // 创建博客

    const blog1 = await Blog.create({
        title : '标题1',
        content : '内容1',
        userId : 2
    });

    console.log('blog1', blog1.dataValues);
})()
```

> 执行 node src/create.js



#### 10.2 查询

> 2、查询

```markdown
const {Blog, User} = require('./model');

!(async function () {
    // 单个一条记录查询
    const zhangsan = await User.findOne({
        where : {
            userName : 'zhangsan'
        }
    });
    console.log('zhangsan ==>',zhangsan.dataValues);

    // 查询特定的列
    const zhangsanName = await User.findOne({
        attributes : ['userName','nickName'],
        where : {
            userName : 'zhangsan'
        }
    })
    console.log('zhangsanName ==>',zhangsanName.dataValues);

    // 查询列表 降序排列
    const blogList = await Blog.findAll({
        attributes : ['title','content'],
        where : {
            userId : 2
        },
        order : [
            ['id','desc']
        ]
    });
    // 数组打印
    console.log('blogList ==>',blogList.map(blog => blog.dataValues));

    // 或者
    for (let blog of blogList) {
        console.log(blog.dataValues);
    }
    

    // 分页
    const blogPageList = await Blog.findAll({
        limit : 2,  // 限制本次查询 2 条
        offset : 1, // 跳过第一条
        order: [
            ['id', 'desc']
        ]
    });
    // 数组打印
    console.log('blogPageList ==>',blogPageList.map(blog => blog.dataValues));


    // 查询总数 
    /**
     * 1、一共有多少条
     * 2、返回总共的条数
     * 3、返回当前的数据
     */
    const blogListAndCount = await Blog.findAndCountAll({
        limit : 2,  // 限制本次查询 2 条
        offset : 1, // 跳过第一条
        order: [
            ['id', 'desc']
        ]
    });
    console.log('blogListAndCount == ',blogListAndCount.count);
    console.log('blogListAndCount == ',blogListAndCount);
    console.log('blogListAndCount == ',blogListAndCount.rows.map(blog => blog.dataValues));
    
    let res = {
        count : blogListAndCount.count,
        rows : blogListAndCount.rows.map(blog => blog.dataValues),
    };
    
    console.log("res ==> ",res);
    
    // 只查询数量
    const blogCount = await Blog.count({
        where : {
            userId : 2
        } 
    });
    console.log("blogCount ===>",blogCount);
    
})()
```



#### 10.3 连表查询

> 3 连表查询1

```markdown
# 1、model表已经建立了外键关系
	// 关联外键
  Blog.belongsTo(User,{
      // 创建外键 Blog.userId -> User.id
      foreignKey : 'userId'
  })
  
# 2、输出数据格式变换很重要
```



```js
// 连表查询  
const blogWithUser = await Blog.findAll({
    attributes : ['title','content'],
    include : [
        {
            model : User,
            attributes : ['userName','nickName'],
            where : {
                //  userName : '张三'
            }
        }
    ],
    where : {
        userId : 2
    },
    order : [
        ['id', 'desc']
    ]
});
console.log("blogWithUser ===>",blogWithUser);
console.log("blogWithUser ===>",blogWithUser.map(blogs => blogs.dataValues));

// 很重要
console.log("blogWithUser ===>",blogWithUser.map(blogs => {
    const data = blogs.dataValues;
    data.user = blogs.dataValues.user.dataValues;
    return data;
}));
```



> 连表查询2

```js
// 关联外键，可以根据User 查到 Blog
User.hasMany(Blog, {
    foreignKey : 'userId'
})

// 可以利用User 查询 Blog
// 连表查询2
    const userWithBlog = await User.findAll({
        attributes : ['userName','nickName'],
        include : [
            {
                model : Blog,
                attributes : ['id','title','content'],
            }
        ],
        where : {
            id : 1
        },
        order : [
            ['createdAt','desc']
        ]
    });
    console.log("userWithBlog",userWithBlog);
    console.log("userWithBlog ===>",userWithBlog.map(users => users.dataValues));
}

```

#### 10.4 修改

```js
const {Blog, User} = require('./model');

!(async function() {
    // 修改一条记录
    const updateRes = await User.update(
        {
            nickName : '罗翔张三',
        },{
            where : {
                id : 1
            }
        }
    )
    console.log("updateRes=====>",updateRes[0] > 0);
})()
```

#### 10.5 删除

```js
const {Blog, User} = require('./model');

!(async function() {

    // 删除一条记录 [硬删除]
    const deleteRes = await Blog.destroy({
        where : {
            id : 2
        }
    })
    console.log("deleteRes====>",deleteRes > 0);
})()
```

#### 10.6 连接池 【有问题】

> 如果没有连接池，每个用户都来创建一个连接，（mysql 默认是8小时候自动断开连接）

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211005174337460.png" alt="image-20211005174337460" style="zoom: 33%;" />

> 如果有连接池，连接池已经创建好了很多连接了。来

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211005174549113.png" alt="image-20211005174549113" style="zoom:33%;" />

```js
// 线上环境，使用连接池
// conf.pool = {
//     max : 5,  // 连接池中最大的连接数量
//     min : 0,
//     idle : 10000  // 一个连接池10s 内没有被使用就会被释放
// }
```

#### 10.7 总结

```markdown
# 1、创建sequelize实例
# 2、建立数据模型 model.js 【表，表与表之间的关系】
# 3、创建数据
# 4、查询数据
# 5、删除数据
# 6、修改数据
# 7、连接池
```



## 第三章 

### 1、redis

> redis-server 启动redis
>
> Redis-cli  redis连接



####  1、nodejs 安装redis的安装依赖

> npm i redis --save



#### 2、promise



### 2、Cookie && Session

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211006123345642.png" alt="image-20211006123345642" style="zoom:33%;" />



> Session 不能放在内存中的原因：
>
> ​	1、一个服务器可以启动多个进程，比如一个电脑可以打开多个网页，qq。
>
> ​			a. 操作系统会限制一个进程的最大可用内存。  
>
> ​			b. 每个进程的数据不是共享的，session也不是共享的。

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211006124231299.png" alt="image-20211006124231299" style="zoom:33%;" />

### 3、 session 存放在redis中

> redis 的容量可以扩展

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211006130244735.png" alt="image-20211006130244735" style="zoom:33%;" />

```markdown
# 1、将web server 和 redis 拆分为两个单独的服务
# 2、双方都是独立的，都是可以扩展的
# 3、mysql 也是一个单独的服务，也可以扩展
```



### 4、为何session 适合用redis ?

> 1、session 访问频繁，对性能要求高
>
> 2、session可以不考虑掉电丢失的问题
>
> 3、session 数据量不会太大 【相比于mysql 存储的数据】





### 5、介绍登录-koa2配置session

> 1、安装依赖
>
> ​	1、npm i koa-redis koa-generic-session --save
>
> 2、在app.js 引入

```js
const redisStore = require('koa-redis')
const session = require('koa-generic-session')
```



```js
// 自动将 session 的值key的值存入到 redis 中
app.keys = ['UIsdf_787#s%'];  // 加密 这个是我随便起的
app.use(session({
  key : 'weibo.sid',  // cookie key的 默认值是 'koa.sid'
  prefix : 'weibo.sess:', // redis key 的前缀，默认是 koa:sess:
  cookie : {
    path: '/',
    httpOnly : true,
    maxAge: 24 * 60 * 60 * 1000 // ms  cookie过期时间，redis的过期时间也是这个
  },
  store : redisStore({
    all : `${REDIS_CONF.host}:${REDIS_CONF.port}`
  })
}))
```



### 6、单元测试 Jest

```markdown
# 意义：一次性执行所有的单元测试，短时间内验证所有功能是否正常

# 安装 jest 只是在 dev 环境下使用
	npm i jest --save-dev 
	
# 在 package.json 的 test 中加入
 "test": "cross-env NODE_ENV=test jest --runInBand --forceExit --colors"
 
# 启动测试 npm run test

# 启动 dev: npm run dev
```

1. 文件名 *.test.js

2. 常用的断言

```markdown
/**
 * @description test demo
 * @author ljs
 */

function sum(a, b) {
     return a + b;
 }

 test('10 + 20 应该等于 30',() => {
     const res = sum(10, 20);
     //expect(res).toBe(31);
     expect(res).not.toBe(40);
 })
 
# 执行 npm run test
```

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211006171808955.png" alt="image-20211006171808955" style="zoom:33%;" />

3. 测试http接口

   > 安装 supertest 依赖
   >
   > Npm i supertest --save-dev

   ```js
   # 在test 文件夹中建立一个 server.js 文件
   const superTest = require('supertest');
   
   const server = require('../src/app').callback()
   
   module.exports = superTest(server);
   
   ```

   > 测试 router/index.js 文件中 json的路由

   ```js
   const { TestWatcher } = require('jest');
   const server = require('./server');
   
   test ('json 接口返回数据格式正确',async () => {
       const res = await server.get('/json');
       expect(res.body).toEqual({
           title: 'koa2 json',
       })
   })
   ```

   > 启动 npm run test





### 7. git 版本 回退 【借助 github】

https://www.jianshu.com/p/3020740561a8



### 8.  Eslint  和  pre-commit  [不会]







### 9. inspect 调试  [垃圾]

> Package.json 中 scripts 文件
>
> "dev": "cross-env NODE_ENV=dev ./node_modules/.bin/nodemon --inspect=9229 bin/www",



```markdown
# 调试的具体方法
	1、启动程序  npm run dev
	2、在 浏览器中输入 chrome://inspect
```

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211016224036569.png" alt="image-20211016224036569" style="zoom:50%;" />

> 调试的界面

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211016224246637.png" alt="image-20211016224246637" style="zoom:67%;" />



### 10.调试工具二  vscode

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211016232130868.png" alt="image-20211016232130868" style="zoom:50%;" />

> 调试和断点，选择node.js





### 11、jwt

```markdown
# 1、jwt - json web token
# 用户认证成功之后，server 端返回一个加密的 token 给客户端
# 客户端后序每次请求都会带上 token , 以表示当前用户身份

```

1、具体步骤

```markdown
# 1、创建项目： 
	koa2 -e 项目名称
				eg:  koa2 -e koa2-weibo-code
				
# 2、淘宝镜像
	npm install -g cnpm --registry=https://registry.npm.taobao.org
	
# 3、cnpm i --save 安装各种依赖

# 4、启动 npm run dev

# 5、安装 koa-jwt
  npm i koa-jwt --save --registry=https://registry.npmmirror.com

# 6、引用
  app.js 文件引入
	const JWT = require('koa-jwt')
	
	
app.use(JWT({
  secret : SECRET
}).unless({
  path : [/^\/users\/login/]   // 自定义哪些目录忽略 jwt 的验证，因为第一次登录，没有token
}))


# 7、加密  安装 jsonwebtoken
  npm i jsonwebtoken --save  --registry=https://registry.npmmirror.com
 
```



```js
// 测试 jwt 
router.post('/login/test', async (ctx, next) => {
  const { userName, password } = ctx.request.body;
  let userInfo;
  if (userName === 'zhangsan' && password === 'abc') {
    // 登陆成功 ，获取用户信息
    userInfo = {
      userName : userName,
      password : password
    }
  }

  // 加密 userInfo
  let token ;
  if (userInfo) {
    token = jwt.sign(userInfo, SECRET, { expiresIn : '1h'});    // 过期时间 是 1h   token 是存在客户端的
  }

  if (userInfo == null) {
    ctx.body = {
      error : -1,
      message : "登录失败"
    }
    return ;
  }

  ctx.body = {
    error : 0,
    data : token
  }
})
```



<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211017222917121.png" alt="image-20211017222917121" style="zoom:50%;" />





> 访问其他网页，代入 token

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211017234847805.png" alt="image-20211017234847805" style="zoom: 33%;" />

> 代码如下

```js
// 获取用户信息
router.get ('/getUserInfo1', async (ctx, next) => {
  const token = ctx.header.authorization;
  try {
    const payload = await verity(token.split(' ')[1], SECRET);
    ctx.body = {
      error : 0,
      userInfo : payload       // 将 userInfo 的值解析出来
    }
  } catch (ex) {
    ctx.body = {
      error : -1,
      userInfo : 'verify token failed'
    } 
  }
```



<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211018000352355.png" alt="image-20211018000352355" style="zoom:50%;" />



### 12、Jwt  vs  session



> 跨域是对 cookie 有限制的，对 header 没有限制。jwt 存在客户端的 header 中
>
> jwt 在客户端，没到过期时间，不能将此人删除。
>
> session 在服务器中，可以随时将此人删除。
>
> 一般情况下 ： 都可以满足 



<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211018221335898.png" alt="image-20211018221335898" style="zoom:67%;" />

![image-20211018221543112](/Users/doghuang/Library/Application Support/typora-user-images/image-20211018221543112.png)

 

 

   



## 第四章 技术方案设计

### 1、架构设计

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211018225541351.png" alt="image-20211018225541351" style="zoom:40%;" />

 

 



### 2、页面（模板，路由）和 API 设计

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211018231548950.png" alt="image-20211018231548950" style="zoom:30%;" />











### 3、数据模型设计





## 第五章  用户管理 （登录和注册）

### 1、页面：模板和路由

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211021225224378.png" alt="image-20211021225224378" style="zoom:30%;" />

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211021225306728.png" alt="image-20211021225306728" style="zoom: 33%;" />

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211021230401830.png" alt="image-20211021230401830" style="zoom:20%;" />



```markdown
# 拉去一个新的分支 ： 
	1、如果这个分支是用来做新功能的， 以 feature-xxx
	2、如果这个分支是用来改bug的，以 bug-xxx 

	git checkout -b feature-login  拉去一个新的分支
```





> view user 路由开发

```markdown
  const router = require('koa-router')();

  router.get('/login', async (ctx, next) => {
      // 返回给 login.js 页面的数据
      await ctx.render('login',{});
  })

  router.get('/register', async (ctx, next) => {
      // 返回给 register.js 页面的数据
    await ctx.render('register',{});
  })


  module.exports = router;
```



> 在 app.js 文件中 注册

```js
const user = require('./routes/view/user')


app.use(user.routes(),index.allowedMethods())

```



> 在 jwt 放过

```js
app.use(JWT({
  secret : SECRET
}).unless({
     path : [/^\/login/, /^\/register/]   // 自定义哪些目录忽略 jwt 的验证，因为第一次登录，没有token
                                          // 登录 和 注册不拦截
}))
```





### 2、数据建模

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211023160111819.png" alt="image-20211023160111819" style="zoom:30%;" />

> 创建 User 表

```mysql
const seq = require('../seq');

 const { STRING, INTEGER, DECIMAL} = require('../type')

 // User 模型 表名是 users
 const User = seq.define('users', {
     // id 会自动创建，并设置为主键，自增
     userName : {
         type : STRING,    // varchar (255)
         allowNull : false,
         unique : true,    // 用户名唯一
         comment : '用户名，唯一'
     },
     password : {
         type : STRING,
         allowNull : false,
         comment : '密码'
     },
     nickName : {                   // 可以为空
         type : STRING,
         comment : '昵称'
     },
     gender : {
         type : DECIMAL,
         allowNull : false,
         defaultValue : 0,
         comment : '性别 (1 男性 , 2 女性 , 3 保密)'
     },
     picture : {
         type : STRING,
         comment : '图片地址'
     },
     city : {
        type : STRING,
        comment : '城市'
     }
 })

 module.exports = User
```



> 将常用的数据类型放在一起

```mysql
 const { BOOLEAN } = require('sequelize');
 const Sequelize = require('sequelize');
 
 module.exports = {
     STRING : Sequelize.STRING,       
     INTEGER : Sequelize.INTEGER,
     TEXT : Sequelize.TEXT,  
     BIGINT : Sequelize.BIGINT ,
     DECIMAL : Sequelize.DECIMAL, 
     FLOAT : Sequelize.FLOAT ,
     DOUBLE : Sequelize.DOUBLE, 
     BOOLEAN : Sequelize.BOOLEAN
 }
```



> 数据同步  seq.js   单独运行就行

```js
const seq = require('./seq');

// console.log('seq ==>',seq);

// 需要同步的数据
require('./model/index');    // 需要同步的数据

// 测试连接 
seq.authenticate().then( () => {
    console.log('ok');
}).catch( () => {
    console.log('err');
})


// 执行同步  force 无论有在数据库有没有表，都会删除数据库的表，然后重新创建
// process.exit() 创建完表 后退出
seq.sync({ force : true}).then( () => {
    console.log('同步成功');
    process.exit();
})

```



### 3、开发注册功能

#### 1 回顾技术方案

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211023172017585.png" alt="image-20211023172017585" style="zoom:50%;" />

 



#### 2 开发注册接口

```markdown
# 1、在 router api中添加 user.js

 const router = require('koa-router')();
 router.prefix('/api/user')

 // 注册路由
 router.post('/register', async (ctx, next) => {

 })

 // 用户名是否存在
 router.post('/isExist', async (ctx, next) => {
     
 })

 module.exports = router;

# 2、在 app.js 中注册

 
 
```





#### 3 密码加密 & 用户信息验证

```markdown
# 1、将用户的登录密码加密

	1、在 util 文件夹下建立一个 cryp.js 的加密文件
	
	
	
```

```js
/**
 * @description 加密方法
 * @author ljs
 */

 const crypto = require('crypto');
 const { SRCRET_KEY } = require('../conf/constants')
 
 /**
  * md5 加密
  */
 function _md5(content) {
    const md5 = crypto.createHash('md5');   // 按照 md5 的方式加密
    return md5.update(content).digest('hex');  // 16进制
 }

 function doCrypto (content) {
    const str = `password=${content}&key=${SRCRET_KEY}`;        
    return _md5(str);
 }

 module.exports = {
    doCrypto
 }
```



#### 4 数据格式检验

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211024182611173.png" alt="image-20211024182611173" style="zoom:30%;" />

 ```markdown
 # json schema   router 的校验规则
 	1、在 src 文件下创建一个 validator 文件夹
 	
 	// 校验规则
  const SCHEMA = {
     type: 'object',
     properties: {
         userName: {
             type: 'string',
             pattern: '^[a-zA-Z][a-zA-Z0-9_]+$', // 字母开头，字母数字下划线
             maxLength: 255,
             minLength: 2
         },
         password: {
             type: 'string',
             maxLength: 255,
             minLength: 3
         },
         newPassword: {
             type: 'string',
             maxLength: 255,
             minLength: 3
         },
         nickName: {
             type: 'string',
             maxLength: 255
         },
         picture: {
             type: 'string',
             maxLength: 255
         },
     }
 	
 	2、安装 ajv 依赖
 	   npm i ajv --save
 	   
 	3、创建 validate.js 文件
 	
 		 const Ajv = require('ajv');
      const ajv = new Ajv({
          // allErrors : true   // 输出所有的错误 (比较慢)
      })
 
      /**
       * json schema 校验
       * @param {*} schema 规则
       * @param {*} data 校验数据
       */
      function validate(schema, data = {}) {
         const valid = ajv.validate(schema, data) {
             if ( !valid ) {
                 return ajv.errors[0];
             }
         }
      }
 
      module.exports = {
         validate
 	 }
 	 
 ```



、



### 4、开发登录功能





### 5、抽离 loginCheck 中间件





### 6、单元测试

```markdown
"test": "cross-env NODE_ENV=test jest --runInBand --forceExit --colors"
cross-env NODE_ENV=test jest  环境变量是test 
--runInBand  顺序运行
--forceExit 强制退出
--colors  颜色


执行 npm run test
```





> 测试model  User.js  测试这些属性和字段的规则是否真的起到了作用

```js
/**
 * @description 用户数据模型
 * @author ljs
 */

 const seq = require('../seq');

 const { STRING, INTEGER, DECIMAL} = require('../type')

 // User 模型 表名是 users
 const User = seq.define('users', {
     // id 会自动创建，并设置为主键，自增
     userName : {
         type : STRING,    // varchar (255)
         allowNull : false,
         unique : true,    // 用户名唯一
         comment : '用户名，唯一'
     },
     password : {
         type : STRING,
         allowNull : false,
         comment : '密码'
     },
     nickName : {                   // 可以为空
         type : STRING,
         comment : '昵称'
     },
     gender : {
         type : DECIMAL,
         allowNull : false,
         defaultValue : 0,
         comment : '性别 (1 男性 , 2 女性 , 3 保密)'
     },
     picture : {
         type : STRING,
         comment : '图片地址'
     },
     city : {
        type : STRING,
        comment : '城市'
     }
 })

 module.exports = User
```



> 测试代码  

```js
const  User  = require('../../src/db/model/User');

test ('User 模型的各个属性，符合预期', () => {
    // build 会构建一个内存的 User 实例，但是不会提交到数据库中
    const user = User.build({
        userName : 'zhangsan',
        password : 'p12333',
        nickName : '张三',
        // gender : 1,
        picture : 'xxx/xxx.png',
        city : '北京'
    })
    // 验证各个属性
    expect(user.userName).toBe('zhangsan');
    expect(user.password).toBe('p12333');
    expect(user.nickName).toBe('张三');
    expect(user.gender).toBe(0);       // 测试 gender 的默认值是不是 0
    expect(user.picture).toBe('xxx/xxx.png');
    expect(user.city).toBe('北京');
})
```



> 测试数据
>
> 测试接口 （测试数据即使删除）













## 第六章

### 1 用户设置

#### 1 页面：模板和路由

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211102231141247.png" alt="image-20211102231141247" style="zoom:40%;" />





#### 2 开发接口 （修改信息，修改密码，退出登录，图片上传）

> https://blog.csdn.net/ojb98K/article/details/107590088

```markdown
# koa2 图片上传 使用工具 formidable-upload-koa


# 文件转移 使用工具 fs-extra 文件


npm i formidable-upload-koa fs-extra --save
```









```markdown
```





#### 3 单元测试





#### 4 统一文件服务

<img src="/Users/doghuang/Library/Application Support/typora-user-images/image-20211108233850333.png" alt="image-20211108233850333" style="zoom:30%;" />

```markdown
# 问题的引入
	多个机器都部署了这个服务，这个时候用户A在机器1上上传了文件，在此登录的时候，在机器2上操作，发现没有了文件

# 统一文件服务
	只要上传到第三方【小公司这样做】，就不用管了
```







# 细节

## 1、依赖

后面加入  --registry=https://registry.npmmirror.com

npm i koa-jwt --save --registry=https://registry.npmmirror.com



## 2、await 代码测试

```js
const redis = require("redis");
const client = redis.createClient( 6379, '127.0.0.1');
const fse = require('fs-extra');
const path = require('path');

/**
 * @description 测试 redis 的操作
 */

async function redisOperator() {
    await client.set('黄石没5','李杰生1');
    console.log('1');
    await client.set('黄石没2','李杰生2');
    console.log('2');
    await client.set('黄石没3','李杰生3');
    console.log('3');
}

async function fileOperator() {
    let url = path.join(__dirname,'upload');
    console.log('url===>', url);
    let isExist = await fse.pathExists(url);
    if (!isExist) {
        // 不存在文件，创建文件
        await fse.mkdirs(url);
    }
}

fileOperator();

module.exports = {
    redisOperator
}


# fse 文件操作模块
https://blog.csdn.net/weixin_33968104/article/details/88005109
```
